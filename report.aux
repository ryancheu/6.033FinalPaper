\relax 
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces  An application that consists of two disjoint jobs. The vertices represent VMs, and the edges represent communication between VMs within the application. If we were to run the jobs in series rather than in parallel, the cost might be slightly lower but the time required would be twice as long.}}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces The report data structure for one VM is shown above. Report is an associated array with key, value as follows. key is a VM id that communicated with this VM over the past 100 msec. The associated value is the number of bytes this VM communicated with the VM with id key in the past 100 msec.}}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces $VM_b$ communicates with group 1 more than its own group. If there is an open slot, $VM_b$ should be moved to group 1.}}{6}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Group 1 and group 2 do not have any open slots, but it would be beneficial to switch the locations of $VM_a$ and $VM_b$.}}{7}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Phase 1 of the basic algorithm. The maximum sizes of each of the four clusters are specified, and the algorithm finds a configuration in which inter-cluster communication is (approximately) minimized. In the figure, inter-cluster communication is highlighted in red.}}{9}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces In phase two, we assign the VMs within each cluster to groups. The number of available slots in each group is specified, and the VMMinKcut algorithm finds an assignment for which inter-group communication is (approximately) minimized. In the above picture, group 1 is highlighted in pink, group 2 is outlined with a dashed line, and inte-group communication is highlighted in bold red.}}{10}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces  Improvements 2 and 3. To simplify the diagram, we consider only a single cluster, depicted above. Improvement 3 involves ignoring highly occupied groups. In the above example, the groups with fewer than 5 available slots are ignored. Improvement 2 then incorporates a “leeway” of b=10 to the actual number of available slots. Ultimately, the number of slots in this cluster made available to the VMMinKcut algorithm is 130.}}{12}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces  In step 1, the macro coordinator collects information on group occupancy. Next, in step 2, another user places 10 VMs in group A, decreasing the occupancy. Finally, in step 3, the macro coordinator tries to execute the placements it calculated and place 18 VMs in group A. Unfortunately, since another user already placed 10 VMs in group A, the placement the macro coordinator calculated is invalid. }}{15}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Line thickness indicates magnitude of data transfer.}}{16}}
